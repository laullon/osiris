Project OSIRIS Source Dump - Sun Feb  1 18:27:51 CET 2026
-----------------------------------

**src/ui/renderer.rs**
```rust
use softbuffer::{Context, Surface};
use std::{
    num::NonZeroU32,
    rc::Rc,
    time::{Duration, Instant},
};
use tiny_skia::{Color, PixmapMut};
use winit::window::Window;

use crate::tui::{TuiEngine, GRID_ROWS};
use crate::ui::widgets::common::Widget;

pub struct Renderer {
    pub tui: TuiEngine,
    pub context: Option<Context<Rc<Window>>>,
    pub surface: Option<Surface<Rc<Window>, Rc<Window>>>,
    pub last_frame_time: Duration,
    pub current_fps: u32,
    pub fps_counter: u32,
    pub fps_timer: Instant,
}

impl Renderer {
    pub fn new(tui: TuiEngine) -> Self {
        Self {
            tui,
            context: None,
            surface: None,
            last_frame_time: Duration::ZERO,
            fps_timer: Instant::now(),
            current_fps: 0,
            fps_counter: 0,
        }
    }

    pub fn paint(&mut self, window: &Rc<Window>, root_widget: &mut dyn Widget) {
        let start_time = Instant::now();
        let size = window.inner_size();

        // Prevent crashes on minimize (0 width)
        if size.width == 0 || size.height == 0 {
            return;
        }

        if self.surface.is_none() {
            let context = Context::new(window.clone()).unwrap();
            let surface = Surface::new(&context, window.clone()).unwrap();
            self.context = Some(context);
            self.surface = Some(surface);
        }

        let surface = self.surface.as_mut().unwrap();

        // 1. NATIVE RESOLUTION (Fixes "Small Box" issue)
        // We use the exact physical pixels of the window.
        let buf_width = size.width;
        let buf_height = size.height;

        surface
            .resize(
                NonZeroU32::new(buf_width).unwrap(),
                NonZeroU32::new(buf_height).unwrap(),
            )
            .unwrap();

        // 2. ZERO-COPY ACCESS
        let mut buffer = surface.buffer_mut().unwrap();

        let raw_bytes: &mut [u8] = unsafe {
            std::slice::from_raw_parts_mut(buffer.as_mut_ptr() as *mut u8, buffer.len() * 4)
        };

        if let Some(mut pixmap) = PixmapMut::from_bytes(raw_bytes, buf_width, buf_height) {
            // 3. COLOR SETUP (BGR for Direct Writing)
            let bg_color = Color::from_rgba8(5, 10, 0, 255);
            let cyan = Color::from_rgba8(255, 255, 0, 255); // R/B Swapped
            let green = Color::from_rgba8(0, 255, 0, 255);
            let status_bg = Color::from_rgba8(20, 20, 20, 255);

            // 4. DRAW
            pixmap.fill(bg_color);
            let metrics = self.tui.calculate_metrics(buf_width, buf_height);

            self.tui.draw_box(
                &mut pixmap,
                &metrics,
                1,
                1,
                metrics.cols - 2,
                GRID_ROWS - 2,
                cyan,
            );

            let title = " OSIRIS MISSION TERMINAL ";
            self.tui.draw_string(
                &mut pixmap,
                &metrics,
                title,
                (metrics.cols / 2).saturating_sub(title.len() / 2),
                0,
                cyan,
            );

            // DRAW ROOT WIDGET
            root_widget.set_rect(2, 2, metrics.cols - 4, GRID_ROWS - 4);
            root_widget.draw(&mut pixmap, &self.tui, &metrics);

            let bar_y = GRID_ROWS - 1;
            let stats_msg = format!(
                " [ RENDER: {:>5.2?} | FPS: {:>3} ] ",
                self.last_frame_time, self.current_fps
            );

            self.tui.draw_string_ex(
                &mut pixmap,
                &metrics,
                &" ".repeat(metrics.cols),
                0,
                bar_y,
                Color::TRANSPARENT,
                Some(status_bg),
                1,
            );
            self.tui.draw_string(
                &mut pixmap,
                &metrics,
                &stats_msg,
                metrics.cols.saturating_sub(stats_msg.len()),
                bar_y,
                cyan,
            );
            self.tui.draw_string(
                &mut pixmap,
                &metrics,
                " OSIRIS MISSION CONTROL",
                0,
                bar_y,
                green,
            );

            // if let Some((cmd, instant)) = last_cmd {
            //     if instant.elapsed() < Duration::from_secs(2) {
            //         let msg = format!(">> CMD: {:?}", cmd);
            //         self.tui.draw_string(&mut pixmap, &metrics, &msg, 4, GRID_ROWS - 5, white);
            //     } else { *last_cmd = None; }
            // }
        }

        // 5. PRESENT
        self.last_frame_time = start_time.elapsed();
        buffer.present().unwrap();

        self.fps_counter += 1;
        if self.fps_timer.elapsed() >= Duration::from_secs(1) {
            self.current_fps = self.fps_counter;
            self.fps_counter = 0;
            self.fps_timer = Instant::now();
        }
    }
}

```

**src/ui/mod.rs**
```rust
pub mod renderer;
pub mod tui;
pub mod widgets;

```

**src/ui/tui.rs**
```rust
use ab_glyph::{point, Font, FontRef, PxScale, ScaleFont};
use tiny_skia::{Color, Paint, PixmapMut, Rect, Transform};

pub const GRID_ROWS: usize = 45;

pub struct TuiMetrics {
    pub char_width: f32,
    pub char_height: f32,
    pub font_size: f32,
    pub cols: usize,
}

pub struct TuiEngine {
    pub font: FontRef<'static>,
}

impl TuiEngine {
    pub fn new(font_data: &'static [u8]) -> Self {
        let font = FontRef::try_from_slice(font_data).expect("Failed to parse font");
        Self { font }
    }

    pub fn calculate_metrics(&self, width: u32, height: u32) -> TuiMetrics {
        let char_height = height as f32 / GRID_ROWS as f32;
        let font_size = char_height * 0.90;
        let scale = PxScale::from(font_size);
        let scaled_font = self.font.as_scaled(scale);
        let char_width = scaled_font.h_advance(self.font.glyph_id('M'));
        let cols = (width as f32 / char_width) as usize;

        TuiMetrics {
            char_width,
            char_height,
            font_size,
            cols,
        }
    }

    pub fn draw_string(
        &self,
        pixmap: &mut PixmapMut,
        metrics: &TuiMetrics,
        text: &str,
        col: usize,
        row: usize,
        color: Color,
    ) {
        self.draw_string_ex(pixmap, metrics, text, col, row, color, None, 1);
    }

    pub fn draw_string_ex(
        &self,
        pixmap: &mut PixmapMut, // Changed to PixmapMut for Zero-Copy
        metrics: &TuiMetrics,
        text: &str,
        col: usize,
        row: usize,
        color: Color,
        bg_color: Option<Color>,
        scale_factor: usize,
    ) {
        let scaled_font_size = metrics.font_size * scale_factor as f32;
        let scale = PxScale::from(scaled_font_size);
        let char_w = metrics.char_width * scale_factor as f32;
        let char_h = metrics.char_height * scale_factor as f32;
        let x_start = col as f32 * metrics.char_width;
        let y_start = row as f32 * metrics.char_height;
        let y_baseline = y_start + (char_h * 0.82);

        // 1. DRAW BACKGROUND (Block Operation)
        // We do this in its own scope so the borrow of 'pixmap' ends immediately
        if let Some(bg) = bg_color {
            let total_w = text.chars().count() as f32 * char_w;
            if let Some(rect) = Rect::from_xywh(x_start, y_start, total_w, char_h) {
                let mut paint = Paint::default();
                paint.set_color(bg);
                pixmap.fill_rect(rect, &paint, Transform::identity(), None);
            }
        }

        // 2. DRAW GLYPHS (Direct Pixel Access)
        // This is 50x faster than calling fill_rect for every pixel of text
        let pix_w = pixmap.width() as i32;
        let pix_h = pixmap.height() as i32;

        let r = (color.red() * 255.0) as u8;
        let g = (color.green() * 255.0) as u8;
        let b = (color.blue() * 255.0) as u8;

        let mut x_cursor = x_start;

        // Start mutable borrow of raw pixels
        let pixels = pixmap.pixels_mut();

        for c in text.chars() {
            let glyph = self
                .font
                .glyph_id(c)
                .with_scale_and_position(scale, point(x_cursor, y_baseline));

            if let Some(outlined) = self.font.outline_glyph(glyph) {
                let bounds = outlined.px_bounds();
                outlined.draw(|x, y, coverage| {
                    // Only draw significant pixels to keep text crisp
                    if coverage > 0.2 {
                        let px = bounds.min.x as i32 + x as i32;
                        let py = bounds.min.y as i32 + y as i32;

                        if px >= 0 && px < pix_w && py >= 0 && py < pix_h {
                            let idx = (py * pix_w + px) as usize;
                            let alpha = (coverage * 255.0) as u8;

                            // Simple Integer Blending (Source Over)
                            // This reads the current pixel (likely the background we just drew)
                            // and blends the text color on top.
                            let dest = &mut pixels[idx];

                            if alpha == 255 {
                                // Solid optimization
                                if let Some(p) =
                                    tiny_skia::PremultipliedColorU8::from_rgba(r, g, b, 255)
                                {
                                    *dest = p;
                                }
                            } else {
                                // Alpha blending logic
                                let a = alpha as u32;
                                let inv_a = 255 - a;

                                let out_r =
                                    ((r as u32 * a + dest.red() as u32 * inv_a) / 255) as u8;
                                let out_g =
                                    ((g as u32 * a + dest.green() as u32 * inv_a) / 255) as u8;
                                let out_b =
                                    ((b as u32 * a + dest.blue() as u32 * inv_a) / 255) as u8;
                                let out_a = ((255 * a + dest.alpha() as u32 * inv_a) / 255) as u8;

                                if let Some(blended) = tiny_skia::PremultipliedColorU8::from_rgba(
                                    out_r, out_g, out_b, out_a,
                                ) {
                                    *dest = blended;
                                }
                            }
                        }
                    }
                });
            }
            x_cursor += char_w;
        }
    }

    pub fn draw_box(
        &self,
        pixmap: &mut PixmapMut, // Changed to PixmapMut
        metrics: &TuiMetrics,
        x: usize,
        y: usize,
        w: usize,
        h: usize,
        color: Color,
    ) {
        if w < 2 || h < 2 {
            return;
        }
        // We reuse draw_string which now handles PixmapMut correctly
        self.draw_string(pixmap, metrics, "┌", x, y, color);
        self.draw_string(pixmap, metrics, "┐", x + w - 1, y, color);
        self.draw_string(pixmap, metrics, "└", x, y + h - 1, color);
        self.draw_string(pixmap, metrics, "┘", x + w - 1, y + h - 1, color);

        let h_line = "─".repeat(w.saturating_sub(2));
        self.draw_string(pixmap, metrics, &h_line, x + 1, y, color);
        self.draw_string(pixmap, metrics, &h_line, x + 1, y + h - 1, color);

        for i in 1..h.saturating_sub(1) {
            self.draw_string(pixmap, metrics, "│", x, y + i, color);
            self.draw_string(pixmap, metrics, "│", x + w - 1, y + i, color);
        }
    }
}

```

**src/ui/widgets/game.rs**
```rust
use crate::{
    tui::{TuiEngine, TuiMetrics},
    ui::widgets::common::Widget,
};
use tiny_skia::{Color, PixmapMut};

pub struct GameWidget {
    selected_item: String,
    pub x: usize,
    pub y: usize,
    pub w: usize,
    pub h: usize,
    // We will pass the selected item string to the draw function
}

impl GameWidget {
    pub fn new(x: usize, y: usize, w: usize, h: usize) -> Self {
        Self {
            selected_item: "SYSTEM: UNKNOWN MODULE".to_string(),
            x,
            y,
            w,
            h,
        }
    }
}
impl Widget for GameWidget {
    fn draw(&self, pixmap: &mut PixmapMut, engine: &TuiEngine, metrics: &TuiMetrics) {
        // COLORS (BGR for Zero-Copy)
        let cyan = Color::from_rgba8(255, 255, 0, 255);
        let green = Color::from_rgba8(0, 255, 0, 255);
        let white = Color::from_rgba8(255, 255, 255, 255);
        let dark_bg = Color::from_rgba8(5, 15, 5, 255);
        let bg_main = Color::from_rgba8(5, 10, 0, 255);

        // 1. Draw Container Frame
        engine.draw_box(pixmap, metrics, self.x, self.y, self.w, self.h, cyan);
        engine.draw_string_ex(
            pixmap,
            metrics,
            " MODULE DETAILS ",
            self.x + 2,
            self.y,
            cyan,
            Some(bg_main),
            1,
        );

        let parts: Vec<&str> = self.selected_item.split(": ").collect();
        let system = parts.get(0).unwrap_or(&"UNKNOWN");
        let title = parts.get(1).unwrap_or(&"UNKNOWN MODULE");

        // 3. Draw Large Title
        engine.draw_string_ex(
            pixmap,
            metrics,
            title,
            self.x + 2,
            self.y + 2,
            white,
            None,
            2, // 2x Scale
        );

        // 4. Draw System Info
        engine.draw_string(
            pixmap,
            metrics,
            &format!("PLATFORM: {}", system),
            self.x + 2,
            self.y + 5,
            green,
        );
        engine.draw_string(
            pixmap,
            metrics,
            "STATUS:   INSTALLED",
            self.x + 2,
            self.y + 6,
            green,
        );
        engine.draw_string(
            pixmap,
            metrics,
            "VERSION:  REV 1.0",
            self.x + 2,
            self.y + 7,
            green,
        );

        // 5. Draw "Image" Placeholder Box
        let img_w = self.w.saturating_sub(4); // Use dynamic self.w
        let img_h = 14;
        let img_y = self.y + 10;

        // Fill
        engine.draw_string_ex(
            pixmap,
            metrics,
            &" ".repeat(img_w),
            self.x + 2,
            img_y,
            Color::TRANSPARENT,
            Some(dark_bg),
            1,
        );

        // Outline (re-uses dynamic width)
        engine.draw_box(pixmap, metrics, self.x + 2, img_y, img_w, img_h, cyan);

        // Centered "NO SIGNAL"
        let no_sig = "NO VISUAL FEED";
        let text_x = self.x + 2 + (img_w / 2).saturating_sub(no_sig.len() / 2);
        engine.draw_string(
            pixmap,
            metrics,
            no_sig,
            text_x,
            img_y + (img_h / 2),
            Color::from_rgba8(100, 100, 100, 255),
        );

        // 6. Stats Footer
        let play_count = (self.selected_item.len() * 3) % 99; // Fake random number
        let stats = format!("PLAY COUNT: {:03} | RATING: A+", play_count);
        engine.draw_string(
            pixmap,
            metrics,
            &stats,
            self.x + 2,
            self.y + self.h - 2,
            white,
        );
    }

    fn set_rect(&mut self, x: usize, y: usize, w: usize, h: usize) {
        self.x = x;
        self.y = y;
        self.w = w;
        self.h = h;
    }

    fn handle_command(&mut self, cmd: crate::commands::NavCommand) {
        match cmd {
            crate::commands::NavCommand::Select => {
                todo!("Implement module selection action");
            }
            _ => {}
        }
    }
}

```

**src/ui/widgets/list.rs**
```rust
use crate::commands::NavCommand;
use crate::tui::{TuiEngine, TuiMetrics};
use tiny_skia::{Color, PixmapMut};

pub struct ListWidget {
    pub title: String,
    pub x: usize,
    pub y: usize,
    pub w: usize,
    pub h: usize,
    pub items: Vec<String>,
    pub selected_index: usize,
    pub scroll_offset: usize,
}

impl ListWidget {
    pub fn new(title: &str, x: usize, y: usize, w: usize, h: usize, items: Vec<String>) -> Self {
        Self {
            title: title.to_string(),
            x,
            y,
            w,
            h,
            items,
            selected_index: 0,
            scroll_offset: 0,
        }
    }
}

impl crate::ui::widgets::common::Widget for ListWidget {
    fn handle_command(&mut self, cmd: NavCommand) {
        let vis_h = self.h.saturating_sub(2);
        if vis_h == 0 {
            return;
        }

        match cmd {
            NavCommand::Up if self.selected_index > 0 => self.selected_index -= 1,
            NavCommand::Down if self.selected_index < self.items.len().saturating_sub(1) => {
                self.selected_index += 1
            }
            _ => {}
        }

        // Keep selection in view
        if self.selected_index < self.scroll_offset {
            self.scroll_offset = self.selected_index;
        } else if self.selected_index >= self.scroll_offset + vis_h {
            self.scroll_offset = self.selected_index - vis_h + 1;
        }
    }

    fn draw(&self, pixmap: &mut PixmapMut, engine: &TuiEngine, metrics: &TuiMetrics) {
        // COLORS (BGR SWAP applied for direct buffer writing)
        // If Cyan looks Yellow, we must write (255, 255, 0) to get (0, 255, 255)
        let cyan = Color::from_rgba8(255, 255, 0, 255);
        let green = Color::from_rgba8(0, 255, 0, 255);
        let white = Color::from_rgba8(255, 255, 255, 255);
        let grey = Color::from_rgba8(180, 180, 180, 255);

        // Dark Cyan Highlight (Swapped R/B)
        let highlight_bg = Color::from_rgba8(60, 60, 0, 255);

        // Main Background (Dark Green/Black)
        let bg_main = Color::from_rgba8(5, 10, 0, 255);

        // 1. Draw Outer Frame
        engine.draw_box(pixmap, metrics, self.x, self.y, self.w, self.h, cyan);

        // 2. Draw Title
        engine.draw_string_ex(
            pixmap,
            metrics,
            &format!(" {} ", self.title),
            self.x + 2,
            self.y,
            green,
            Some(bg_main),
            1,
        );

        // 3. Draw Items
        let vis_h = self.h.saturating_sub(2);
        for i in 0..vis_h {
            let idx = i + self.scroll_offset;
            if idx >= self.items.len() {
                break;
            }

            let text_w = self.w.saturating_sub(4);
            let raw_text = &self.items[idx];
            let display_text = if raw_text.len() > text_w {
                format!("{}…", &raw_text[..text_w.saturating_sub(1)])
            } else {
                format!("{:<width$}", raw_text, width = text_w)
            };

            if idx == self.selected_index {
                // Highlighted Item
                engine.draw_string_ex(
                    pixmap,
                    metrics,
                    &display_text,
                    self.x + 2,
                    self.y + 1 + i,
                    white,
                    Some(highlight_bg),
                    1,
                );
            } else {
                // Normal Item
                engine.draw_string(
                    pixmap,
                    metrics,
                    &display_text,
                    self.x + 2,
                    self.y + 1 + i,
                    grey,
                );
            }
        }

        // 4. Draw Scrollbar
        if self.items.len() > vis_h {
            let bar_x = self.x + self.w - 1;
            let total_items = self.items.len() as f32;
            let track_h = vis_h as f32;

            // Calculate handle relative position
            let scroll_pct = self.scroll_offset as f32 / (total_items - track_h).max(1.0);
            let handle_y = (scroll_pct * (track_h - 1.0)).round() as usize;

            for i in 0..vis_h {
                let symbol = if i == handle_y { "█" } else { "▒" };

                // Draw with a background to overwrite the border line
                engine.draw_string_ex(
                    pixmap,
                    metrics,
                    symbol,
                    bar_x,
                    self.y + 1 + i,
                    cyan,
                    Some(bg_main),
                    1,
                );
            }
        }
    }

    fn set_rect(&mut self, x: usize, y: usize, w: usize, h: usize) {
        self.x = x;
        self.y = y;
        self.w = w;
        self.h = h;
    }
}

```

**src/ui/widgets/mod.rs**
```rust
pub(crate) mod common;
pub mod game;
pub mod list;
pub mod panel;

pub use game::GameWidget;
pub use list::ListWidget;

```

**src/ui/widgets/panel.rs**
```rust
use crate::ui::widgets::common::{Container, Widget};

pub struct SplitPanelWidget<L: Widget, R: Widget> {
    left: L,
    right: R,
    split_ratio: u32,
    percentage_mode: bool,
    is_vertical: bool,
    x: usize,
    y: usize,
    w: usize,
    h: usize,
}

impl<L: Widget, R: Widget> SplitPanelWidget<L, R> {
    pub fn new(
        left: L,
        right: R,
        split_ratio: u32,
        percentage_mode: bool,
        is_vertical: bool,
    ) -> Self {
        let mut panel = Self {
            left,
            right,
            split_ratio,
            percentage_mode,
            is_vertical,
            x: 0,
            y: 0,
            w: 0,
            h: 0,
        };
        panel.arrange_widgets();
        panel
    }
}

impl<L: Widget, R: Widget> Container for SplitPanelWidget<L, R> {
    fn arrange_widgets(&mut self) {
        if self.w == 0 || self.h == 0 {
            return;
        }

        if self.is_vertical {
            let split_point = if self.percentage_mode {
                (self.h * self.split_ratio as usize) / 100
            } else {
                self.split_ratio as usize
            };

            self.left.set_rect(self.x, self.y, self.w, split_point);
            self.right.set_rect(
                self.x,
                self.y + split_point,
                self.w,
                self.h.saturating_sub(split_point),
            );
        } else {
            let split_point = if self.percentage_mode {
                (self.w * self.split_ratio as usize) / 100
            } else {
                self.split_ratio as usize
            };

            self.left.set_rect(self.x, self.y, split_point, self.h);
            self.right.set_rect(
                self.x + split_point,
                self.y,
                self.w.saturating_sub(split_point),
                self.h,
            );
        }
    }
}

impl<L: Widget, R: Widget> Widget for SplitPanelWidget<L, R> {
    fn draw(
        &self,
        pixmap: &mut tiny_skia::PixmapMut,
        engine: &crate::ui::tui::TuiEngine,
        metrics: &crate::ui::tui::TuiMetrics,
    ) {
        self.left.draw(pixmap, engine, metrics);
        self.right.draw(pixmap, engine, metrics);
    }

    fn set_rect(&mut self, x: usize, y: usize, w: usize, h: usize) {
        self.x = x;
        self.y = y;
        self.w = w;
        self.h = h;
        self.arrange_widgets();
    }

    fn handle_command(&mut self, cmd: crate::commands::NavCommand) {
        // Forward command to both widgets
        self.left.handle_command(cmd.clone());
        self.right.handle_command(cmd);
    }
}

```

**src/ui/widgets/common.rs**
```rust
use tiny_skia::PixmapMut;

use crate::{
    commands::NavCommand,
    ui::tui::{TuiEngine, TuiMetrics},
};

pub(crate) trait Widget {
    fn draw(&self, pixmap: &mut PixmapMut, engine: &TuiEngine, metrics: &TuiMetrics);
    fn set_rect(&mut self, x: usize, y: usize, w: usize, h: usize);
    fn handle_command(&mut self, cmd: NavCommand);
}

pub(crate) trait Container {
    fn arrange_widgets(&mut self);
}

```

**src/commands.rs**
```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NavCommand {
    Up,
    Down,
    Left,
    Right,
    Select,
    Back,
}

```

**src/main.rs**
```rust
mod app;
mod commands;
mod ui;

use crate::ui::{renderer, tui, widgets};
use winit::event_loop::EventLoop;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let event_loop = EventLoop::new()?;

    // Call TuiEngine from the tui module
    let tui_instance =
        ui::tui::TuiEngine::new(include_bytes!("../fonts/JetBrainsMono-Regular.ttf"));

    let mut app = app::OsirisApp::new(
        gilrs::Gilrs::new().unwrap(),
        renderer::Renderer::new(tui_instance),
    );
    event_loop.run_app(&mut app)?;
    Ok(())
}

```

**src/app.rs**
```rust
use crate::commands::NavCommand;
use crate::renderer::Renderer;
use crate::ui::widgets;
use crate::ui::widgets::common::Widget;
use crate::ui::widgets::panel::SplitPanelWidget;
use crate::widgets::{GameWidget, ListWidget};
use gilrs::{Button, EventType, Gilrs};
use std::collections::HashMap;
use std::rc::Rc;
use std::time::{Duration, Instant};
use winit::application::ApplicationHandler;
use winit::event::{ElementState, KeyEvent, WindowEvent};
use winit::event_loop::ActiveEventLoop;
use winit::keyboard::{KeyCode, PhysicalKey};
use winit::window::{Window, WindowId};

const REPEAT_DELAY: Duration = Duration::from_millis(400);
const REPEAT_INTERVAL: Duration = Duration::from_millis(80);

struct CommandState {
    last_trigger: Instant,
    started_at: Instant,
    repeating: bool,
}

pub struct OsirisApp {
    pub gil: Gilrs,
    pub window: Option<Rc<Window>>,
    pub renderer: Renderer,
    root_panel: SplitPanelWidget<ListWidget, GameWidget>,
    active_commands: HashMap<NavCommand, CommandState>,
}

impl ApplicationHandler for OsirisApp {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        if self.window.is_none() {
            let window = Rc::new(
                event_loop
                    .create_window(
                        Window::default_attributes()
                            .with_title("OSIRIS")
                            .with_fullscreen(Some(winit::window::Fullscreen::Borderless(None))),
                    )
                    .unwrap(),
            );
            self.window = Some(window);
        }
    }

    fn window_event(&mut self, _el: &ActiveEventLoop, _id: WindowId, event: WindowEvent) {
        match event {
            WindowEvent::CloseRequested => _el.exit(),
            WindowEvent::KeyboardInput {
                event:
                    KeyEvent {
                        state,
                        physical_key: PhysicalKey::Code(key),
                        repeat: false,
                        ..
                    },
                ..
            } => {
                if let Some(cmd) = self.map_key(key) {
                    if state == ElementState::Pressed {
                        self.press_command(cmd);
                    } else {
                        self.release_command(cmd);
                    }
                }
            }

            WindowEvent::RedrawRequested => {
                if let Some(win) = &self.window {
                    self.renderer.paint(win, &mut self.root_panel);
                }
            }
            _ => {}
        }
    }

    fn about_to_wait(&mut self, _el: &ActiveEventLoop) {
        while let Some(ev) = self.gil.next_event() {
            match ev.event {
                EventType::ButtonPressed(btn, _) => {
                    if let Some(cmd) = self.map_btn(btn) {
                        self.press_command(cmd);
                    }
                }
                EventType::ButtonReleased(btn, _) => {
                    if let Some(cmd) = self.map_btn(btn) {
                        self.release_command(cmd);
                    }
                }
                _ => {}
            }
        }

        let mut changed = false;
        let now = Instant::now();
        for (cmd, state) in self.active_commands.iter_mut() {
            if !matches!(cmd, NavCommand::Up | NavCommand::Down) {
                continue;
            }
            if !state.repeating && now.duration_since(state.started_at) >= REPEAT_DELAY {
                state.repeating = true;
            }
            if state.repeating && now.duration_since(state.last_trigger) >= REPEAT_INTERVAL {
                state.last_trigger = now;
                self.root_panel.handle_command(cmd.clone());
                changed = true;
            }
        }

        if changed {
            if let Some(win) = &self.window {
                win.request_redraw();
            }
        }
    }
}

impl OsirisApp {
    pub fn new(gil: Gilrs, renderer: Renderer) -> Self {
        let items = (1..100)
            .map(|i| format!("MISSION MODULE {:03}", i))
            .collect();

        let game_list = widgets::ListWidget::new(" MODULE SELECTOR ", 3, 2, 40, 41, items);
        let metadata = GameWidget::new(0, 0, 0, 0);

        let root_panel = SplitPanelWidget::new(game_list, metadata, 30, true, false);

        Self {
            gil,
            window: None,
            renderer,
            root_panel,
            active_commands: HashMap::new(),
        }
    }
    fn press_command(&mut self, cmd: NavCommand) {
        if !self.active_commands.contains_key(&cmd) {
            let now = Instant::now();
            self.active_commands.insert(
                cmd.clone(),
                CommandState {
                    last_trigger: now,
                    started_at: now,
                    repeating: false,
                },
            );
            self.root_panel.handle_command(cmd);
            if let Some(win) = &self.window {
                win.request_redraw();
            }
        }
    }
    fn release_command(&mut self, cmd: NavCommand) {
        self.active_commands.remove(&cmd);
    }
    fn map_key(&self, key: KeyCode) -> Option<NavCommand> {
        match key {
            KeyCode::ArrowUp => Some(NavCommand::Up),
            KeyCode::ArrowDown => Some(NavCommand::Down),
            KeyCode::ArrowLeft => Some(NavCommand::Left),
            KeyCode::ArrowRight => Some(NavCommand::Right),
            KeyCode::Space => Some(NavCommand::Select),
            KeyCode::Escape => Some(NavCommand::Back),
            _ => None,
        }
    }
    fn map_btn(&self, btn: Button) -> Option<NavCommand> {
        match btn {
            Button::DPadUp => Some(NavCommand::Up),
            Button::DPadDown => Some(NavCommand::Down),
            Button::DPadLeft => Some(NavCommand::Left),
            Button::DPadRight => Some(NavCommand::Right),
            Button::South => Some(NavCommand::Select),
            Button::East => Some(NavCommand::Back),
            _ => None,
        }
    }
}

```
