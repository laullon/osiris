Project OSIRIS Source Dump - Sat Jan 31 19:10:50 CET 2026
-----------------------------------

**Cargo.toml**
```rust
[package]
name    = "osiris"
version = "0.1.0"
edition = "2021"

[dependencies]
winit = { version = "0.30", features = ["wayland", "x11"] }
softbuffer = "0.4"
tiny-skia = "0.11"
gilrs = "0.11.1"
ab_glyph = "0.2"
```

**src/main.rs**
```rust
mod commands; mod tui; mod renderer; mod app; mod widgets;
use std::collections::HashSet;
use std::time::Instant;
use winit::event_loop::EventLoop;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let event_loop = EventLoop::new()?;
    let tui = tui::TuiEngine::new(include_bytes!("../fonts/JetBrainsMono-Regular.ttf"));
    let items = (1..100).map(|i| format!("MISSION MODULE {:03}", i)).collect();
    let game_list = widgets::ListWidget::new(" MODULE SELECTOR ", 4, 4, 40, 30, items);

    let mut app = app::OsirisApp {
        gil: gilrs::Gilrs::new().unwrap(),
        window: None,
        renderer: renderer::Renderer::new(tui),
        last_cmd: None,
        game_list,
        held_keys: HashSet::new(),
        last_tick: Instant::now(),
    };
    event_loop.run_app(&mut app)?;
    Ok(())
}
```

**src/commands.rs**
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NavCommand {
    Up, Down, Left, Right, Select, Back,
}
```

**src/tui.rs**
```rust
use ab_glyph::{point, Font, FontRef, PxScale, ScaleFont};
use tiny_skia::{Color, Paint, Pixmap, Rect, Transform};

pub const GRID_ROWS: usize = 45;

pub struct TuiMetrics {
    pub char_width: f32,
    pub char_height: f32,
    pub font_size: f32,
    pub cols: usize,
}

pub struct TuiEngine {
    pub font: FontRef<'static>,
}

impl TuiEngine {
    pub fn new(font_data: &'static [u8]) -> Self {
        let font = FontRef::try_from_slice(font_data).expect("Failed to parse font");
        Self { font }
    }

    pub fn calculate_metrics(&self, width: u32, height: u32) -> TuiMetrics {
        let char_height = height as f32 / GRID_ROWS as f32;
        let font_size = char_height * 0.90; 
        let scale = PxScale::from(font_size);
        let scaled_font = self.font.as_scaled(scale);
        let char_width = scaled_font.h_advance(self.font.glyph_id('M'));
        let cols = (width as f32 / char_width) as usize;

        TuiMetrics { char_width, char_height, font_size, cols }
    }

    pub fn draw_string(&self, pixmap: &mut Pixmap, metrics: &TuiMetrics, text: &str, col: usize, row: usize, color: Color) {
        self.draw_string_ex(pixmap, metrics, text, col, row, color, None, 1);
    }

    pub fn draw_string_ex(&self, pixmap: &mut Pixmap, metrics: &TuiMetrics, text: &str, col: usize, row: usize, color: Color, bg_color: Option<Color>, scale_factor: usize) {
        let scaled_font_size = metrics.font_size * scale_factor as f32;
        let scale = PxScale::from(scaled_font_size);
        let char_w = metrics.char_width * scale_factor as f32;
        let char_h = metrics.char_height * scale_factor as f32;
        let x_start = col as f32 * metrics.char_width;
        let y_start = row as f32 * metrics.char_height;
        let y_baseline = y_start + (char_h * 0.82);

        let mut x_cursor = x_start;
        for c in text.chars() {
            if let Some(bg) = bg_color {
                let rect = Rect::from_xywh(x_cursor, y_start, char_w, char_h).unwrap();
                let mut paint = Paint::default();
                paint.set_color(bg);
                pixmap.fill_rect(rect, &paint, Transform::identity(), None);
            }

            let glyph_id = self.font.glyph_id(c);
            let glyph = glyph_id.with_scale_and_position(scale, point(x_cursor, y_baseline));
            if let Some(outlined) = self.font.outline_glyph(glyph) {
                let bounds = outlined.px_bounds();
                outlined.draw(|x, y, coverage| {
                    if coverage > 0.01 {
                        let mut paint = Paint::default();
                        paint.set_color(Color::from_rgba8((color.red() * 255.0) as u8, (color.green() * 255.0) as u8, (color.blue() * 255.0) as u8, (coverage * 255.0) as u8));
                        let rect = Rect::from_xywh(bounds.min.x + x as f32, bounds.min.y + y as f32, 1.0, 1.0).unwrap();
                        pixmap.fill_rect(rect, &paint, Transform::identity(), None);
                    }
                });
            }
            x_cursor += char_w;
        }
    }

    pub fn draw_box(&self, pixmap: &mut Pixmap, metrics: &TuiMetrics, x: usize, y: usize, w: usize, h: usize, color: Color) {
        self.draw_string(pixmap, metrics, "┌", x, y, color);
        self.draw_string(pixmap, metrics, "┐", x + w - 1, y, color);
        self.draw_string(pixmap, metrics, "└", x, y + h - 1, color);
        self.draw_string(pixmap, metrics, "┘", x + w - 1, y + h - 1, color);
        let h_line = "─".repeat(w.saturating_sub(2));
        self.draw_string(pixmap, metrics, &h_line, x + 1, y, color);
        self.draw_string(pixmap, metrics, &h_line, x + 1, y + h - 1, color);
        for i in 1..h.saturating_sub(1) {
            self.draw_string(pixmap, metrics, "│", x, y + i, color);
            self.draw_string(pixmap, metrics, "│", x + w - 1, y + i, color);
        }
    }
}
```

**src/renderer.rs**
```rust
use std::{num::NonZeroU32, rc::Rc, time::Instant};
use softbuffer::{Context, Surface};
use winit::window::Window;

use crate::{commands::NavCommand, tui::TuiEngine, widgets::ListWidget}; // Add this

pub struct Renderer {
    pub tui: TuiEngine,
    // Change these to be permanent
    pub context: Option<Context<Rc<Window>>>,
    pub surface: Option<Surface<Rc<Window>, Rc<Window>>>,
}

impl Renderer {
    pub fn new(tui: TuiEngine) -> Self {
        Self { tui, context: None, surface: None }
    }

    pub fn paint(&mut self, window: &Rc<Window>, last_cmd: &mut Option<(NavCommand, Instant)>, game_list: &ListWidget) {
        let size = window.inner_size();
        if size.width == 0 || size.height == 0 { return; }

        // Initialize Context and Surface ONLY IF they don't exist
        if self.surface.is_none() {
            let context = Context::new(window.clone()).unwrap();
            let surface = Surface::new(&context, window.clone()).unwrap();
            self.context = Some(context);
            self.surface = Some(surface);
        }

        let surface = self.surface.as_mut().unwrap();

        // ONLY resize if the window actually changed
        surface.resize(
            NonZeroU32::new(size.width).unwrap(),
            NonZeroU32::new(size.height).unwrap()
        ).unwrap();

        // ... (rest of your tiny-skia drawing code) ...
        
        let mut buffer = surface.buffer_mut().unwrap();
        // ... (the loop to copy pixels) ...
        buffer.present().unwrap();
    }
}
```

**src/app.rs**
```rust
use crate::commands::NavCommand;
use crate::renderer::Renderer;
use crate::widgets::ListWidget;
use gilrs::{Button, EventType, Gilrs};
use std::collections::HashSet;
use std::rc::Rc;
use std::time::{Duration, Instant};
use winit::application::ApplicationHandler;
use winit::event::{ElementState, KeyEvent, WindowEvent};
use winit::event_loop::ActiveEventLoop;
use winit::keyboard::{KeyCode, PhysicalKey};
use winit::window::{Window, WindowId};

pub struct OsirisApp {
    pub gil: Gilrs,
    pub window: Option<Rc<Window>>,
    pub renderer: Renderer,
    pub last_cmd: Option<(NavCommand, Instant)>,
    pub game_list: ListWidget,
    pub held_keys: HashSet<KeyCode>,
    pub last_tick: Instant,
}

impl ApplicationHandler for OsirisApp {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        if self.window.is_none() {
            let window = Rc::new(
                event_loop
                    .create_window(
                        Window::default_attributes()
                            .with_title("OSIRIS")
                            .with_decorations(false)
                            .with_fullscreen(Some(winit::window::Fullscreen::Borderless(None))),
                    )
                    .unwrap(),
            );
            self.window = Some(window);
        }
    }

    fn window_event(&mut self, event_loop: &ActiveEventLoop, _id: WindowId, event: WindowEvent) {
        match event {
            WindowEvent::CloseRequested => event_loop.exit(),
            
            // Handle Keyboard Input
            WindowEvent::KeyboardInput {
                event:
                    KeyEvent {
                        state,
                        physical_key: PhysicalKey::Code(key),
                        repeat: false, // Ignore OS repeat, we handle it in update_logic
                        ..
                    },
                ..
            } => {
                if state == ElementState::Pressed {
                    self.held_keys.insert(key);
                    // Immediate action on first press
                    if let Some(cmd) = self.map_key(key) {
                        self.game_list.handle_command(cmd);
                        self.last_cmd = Some((cmd, Instant::now()));
                    }
                } else {
                    self.held_keys.remove(&key);
                }
            }

            // Paint when requested
            WindowEvent::RedrawRequested => {
                if let Some(win) = &self.window {
                    self.renderer.paint(win, &mut self.last_cmd, &self.game_list);
                }
            }
            _ => {}
        }
    }

    // High-frequency logic loop
    fn about_to_wait(&mut self, _event_loop: &ActiveEventLoop) {
        // 1. Poll Gamepad (Gilrs doesn't use Winit events)
        while let Some(ev) = self.gil.next_event() {
            if let EventType::ButtonPressed(btn, _) = ev.event {
                let cmd = match btn {
                    Button::South => Some(NavCommand::Select),
                    Button::DPadUp => Some(NavCommand::Up),
                    Button::DPadDown => Some(NavCommand::Down),
                    Button::East => Some(NavCommand::Back),
                    _ => None,
                };
                if let Some(c) = cmd {
                    self.game_list.handle_command(c);
                    self.last_cmd = Some((c, Instant::now()));
                }
            }
        }

        // 2. Handle held keys for rapid scrolling
        self.update_logic();

        // 3. Keep the screen alive
        if let Some(win) = &self.window {
            win.request_redraw();
        }
    }
}

impl OsirisApp {
    fn map_key(&self, key: KeyCode) -> Option<NavCommand> {
        match key {
            KeyCode::ArrowUp => Some(NavCommand::Up),
            KeyCode::ArrowDown => Some(NavCommand::Down),
            KeyCode::Space => Some(NavCommand::Select),
            KeyCode::Escape => Some(NavCommand::Back),
            _ => None,
        }
    }

    fn update_logic(&mut self) {
        // Only tick every 110ms for held keys
        if self.last_tick.elapsed() >= Duration::from_millis(110) {
            let mut moved = false;
            for key in &self.held_keys {
                if let Some(cmd) = self.map_key(*key) {
                    // Only repeat directional navigation
                    if matches!(cmd, NavCommand::Up | NavCommand::Down) {
                        self.game_list.handle_command(cmd);
                        moved = true;
                    }
                }
            }
            if moved {
                self.last_tick = Instant::now();
            }
        }
    }
}
```

**src/widgets/mod.rs**
```rust
// This tells Rust to look for src/widgets/list.rs
pub mod list;

// This makes ListWidget available as crate::widgets::ListWidget
pub use list::ListWidget;
```

**src/widgets/list.rs**
```rust
use crate::commands::NavCommand;
use crate::tui::{TuiEngine, TuiMetrics};
use tiny_skia::{Color, Pixmap};

pub struct ListWidget {
    pub title: String,
    pub x: usize, pub y: usize, pub w: usize, pub h: usize,
    pub items: Vec<String>,
    pub selected_index: usize,
    pub scroll_offset: usize,
}

impl ListWidget {
    pub fn new(title: &str, x: usize, y: usize, w: usize, h: usize, items: Vec<String>) -> Self {
        Self { title: title.to_string(), x, y, w, h, items, selected_index: 0, scroll_offset: 0 }
    }

    pub fn handle_command(&mut self, cmd: NavCommand) {
        let vis_h = self.h.saturating_sub(2);
        match cmd {
            NavCommand::Up if self.selected_index > 0 => self.selected_index -= 1,
            NavCommand::Down if self.selected_index < self.items.len().saturating_sub(1) => self.selected_index += 1,
            _ => {}
        }
        if self.selected_index < self.scroll_offset { self.scroll_offset = self.selected_index; }
        else if self.selected_index >= self.scroll_offset + vis_h { self.scroll_offset = self.selected_index - vis_h + 1; }
    }

    pub fn draw(&self, pixmap: &mut Pixmap, engine: &TuiEngine, metrics: &TuiMetrics) {
        let cyan = Color::from_rgba8(0, 255, 255, 255);
        let highlight = Color::from_rgba8(0, 60, 60, 255);
        engine.draw_box(pixmap, metrics, self.x, self.y, self.w, self.h, cyan);
        engine.draw_string(pixmap, metrics, &format!(" {} ", self.title), self.x + 2, self.y, cyan);

        let vis_h = self.h.saturating_sub(2);
        for i in 0..vis_h {
            let idx = i + self.scroll_offset;
            if idx >= self.items.len() { break; }
            let text = format!("{:<width$}", self.items[idx], width = self.w - 4);
            if idx == self.selected_index {
                engine.draw_string_ex(pixmap, metrics, &text, self.x + 2, self.y + 1 + i, Color::WHITE, Some(highlight), 1);
            } else {
                engine.draw_string(pixmap, metrics, &text, self.x + 2, self.y + 1 + i, Color::from_rgba8(180, 180, 180, 255));
            }
        }
    }
}
```
